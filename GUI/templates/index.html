<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>El Cl√°sico Chess</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body class="game-body">
    <!-- Sound Effects -->
    <audio id="move-sound">
        <source src="/sounds/move_sound.wav" type="audio/wav">
    </audio>
    <audio id="capture-sound">
        <source src="/sounds/piece_removed.wav" type="audio/wav">
    </audio>
    <audio id="promotion-sound">
        <source src="/sounds/p_to_queen.wav" type="audio/wav">
    </audio>
    <audio id="gameover-sound">
        <source src="/sounds/loss_game.wav" type="audio/wav">
    </audio>
    <div class="game-container">
        <!-- Header -->
        <div class="game-header">
            <div class="header-content">
                <h1>El Cl√°sico Chess</h1>
                <div class="teams-display">
                    <div class="team-info barcelona">
                        <img src="/static/images/barcelona-logo.png" alt="Barcelona" class="team-logo">
                        <span class="team-name">Barcelona</span>
                    </div>
                    <span class="vs">VS</span>
                    <div class="team-info madrid">
                        <img src="/static/images/real-madrid-logo.png" alt="Real Madrid" class="team-logo">
                        <span class="team-name">Real Madrid</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-main">
            <!-- Board Section -->
            <div class="board-section">
                <div id="chessboard" class="chessboard">
                    <!-- Board will be generated by JavaScript -->
                </div>
                <div class="board-info">
                    <p id="turn-indicator" class="turn-indicator">Turn: Real Madrid (White)</p>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="game-sidebar">
                <div class="sidebar-card">
                    <h3>Game Status</h3>
                    <div id="game-status" class="game-status">
                        <p id="status-text">Game in progress...</p>
                    </div>
                </div>

                <div class="sidebar-card">
                    <h3>Controls</h3>
                    <div class="controls">
                        <button id="undo-btn" class="control-btn undo-btn" onclick="undoMove()">
                            ‚Ü©Ô∏è Undo Move
                        </button>
                        <button id="restart-btn" class="control-btn restart-btn" onclick="restartGame()">
                            üîÑ Restart Game
                        </button>
                        <a href="/" class="control-btn menu-btn">
                            üè† Main Menu
                        </a>
                    </div>
                </div>

                <div class="sidebar-card">
                    <h3>Last Move</h3>
                    <p id="last-move" class="last-move">-</p>
                </div>

                <div class="sidebar-card">
                    <h3>How to Play</h3>
                    <ul class="instructions">
                        <li>Click a piece to select it</li>
                        <li>Click a highlighted square to move</li>
                        <li>Undo moves with the Undo button</li>
                        <li>Game ends when checkmate occurs</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Winner Modal -->
    <div id="winner-modal" class="winner-modal hidden">
        <div class="winner-content">
            <div id="winner-announcement" class="winner-announcement">
                <!-- Will be populated by JavaScript -->
            </div>
            <div class="winner-buttons">
                <button class="winner-btn restart" onclick="restartGame()">üîÑ Play Again</button>
                <a href="/" class="winner-btn menu">üè† Main Menu</a>
            </div>
        </div>
    </div>

    <script>
        /* jshint ignore:start */
        const GAME_ID = "{{ game_id }}";
        const MODE = parseInt("{{ mode }}");
        const PLAYER_TEAM = "{{ player_team }}";
        /* jshint ignore:end */
        let selectedSquare = null;
        let legalMoves = [];
        let lastMove = null;
        let previousBoard = null;  // Track previous board state
        let isWaitingForMove = false;  // Prevent rapid successive moves

        // Initialize board on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            updateBoard();
            
            // For AI vs AI, start the auto-play
            if (MODE === 3) {
                setTimeout(playAIvsAI, 500);
            }
            
            // For Human vs AI, if player chose Barcelona (black), let AI make first move
            if (MODE === 2 && PLAYER_TEAM === 'barcelona') {
                setTimeout(() => {
                    // Store board state before AI move
                    fetch(`/api/board/${GAME_ID}`)
                        .then(r => r.json())
                        .then(boardData => {
                            const boardBeforeMove = JSON.parse(JSON.stringify(boardData.board));
                            
                            fetch(`/api/ai_move/${GAME_ID}`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'}
                            })
                            .then(r => r.json())
                            .then(data => {
                                if (data.success && data.ai_move) {
                                    document.getElementById('last-move').textContent = data.ai_move;
                                    
                                    // Check if move was a capture
                                    const piecesBeforeCount = boardBeforeMove.filter(sq => sq.piece).length;
                                    const piecesAfterCount = data.board.filter(sq => sq.piece).length;
                                    const wasCapture = piecesAfterCount < piecesBeforeCount;
                                    
                                    if (wasCapture) {
                                        playCaptureSound();
                                    } else {
                                        playMoveSound();
                                    }
                                    
                                    updateBoard();
                                }
                            });
                        });
                }, 500);
            }
        });

        function playAIvsAI() {
            // Check if game is over first
            fetch(`/api/board/${GAME_ID}`)
                .then(r => r.json())
                .then(data => {
                    if (!data.game_over) {
                        // Store board state before AI move
                        const boardBeforeMove = JSON.parse(JSON.stringify(data.board));
                        
                        // Make an AI move
                        fetch(`/api/ai_move/${GAME_ID}`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'}
                        })
                        .then(r => r.json())
                        .then(moveData => {
                            if (moveData.success) {
                                document.getElementById('last-move').textContent = moveData.ai_move || 'AI moved';
                                
                                console.log('AI Move Response:', moveData.ai_move);
                                console.log('Board piece count from API:', moveData.board.filter(sq => sq.piece).length);
                                
                                // Check if move was a capture by comparing piece counts
                                const piecesBeforeCount = boardBeforeMove.filter(sq => sq.piece).length;
                                const piecesAfterCount = moveData.board.filter(sq => sq.piece).length;
                                const wasCapture = piecesAfterCount < piecesBeforeCount;
                                
                                console.log('Before:', piecesBeforeCount, 'After:', piecesAfterCount, 'Capture:', wasCapture);
                                console.log('Full board data:', moveData.board);
                                
                                // Play appropriate sound
                                if (wasCapture) {
                                    playCaptureSound();
                                } else {
                                    playMoveSound();
                                }
                                
                                // Update board directly with the returned board data
                                updateBoardWithData(moveData.board);
                                
                                // Update turn indicator and game status
                                const turnText = moveData.side_to_move === 'white' 
                                    ? 'Real Madrid (White)' 
                                    : 'Barcelona (Black)';
                                document.getElementById('turn-indicator').textContent = `Turn: ${turnText}`;
                                
                                if (moveData.game_over) {
                                    const winner = moveData.winner === 'madrid' ? 'Real Madrid' : 'Barcelona';
                                    const winnerTeam = moveData.winner;
                                    const winnerEmoji = winnerTeam === 'madrid' ? 'üëë' : 'üîµ';
                                    showWinnerModal(winner, winnerTeam, winnerEmoji);
                                }
                                
                                // Schedule next move after 500ms
                                if (!moveData.game_over) {
                                    setTimeout(playAIvsAI, 500);
                                }
                            }
                        });
                    }
                });
        }

        function initializeBoard() {
            const board = document.getElementById('chessboard');
            board.innerHTML = '';
            
            // Flip board if player is Real Madrid (white) so they're at bottom
            const shouldFlip = PLAYER_TEAM === 'madrid';
            
            for (let i = 0; i < 64; i++) {
                const square = document.createElement('div');
                
                // If flipped, reverse the index
                const displayIndex = shouldFlip ? (63 - i) : i;
                const row = Math.floor(displayIndex / 8);
                const col = displayIndex % 8;
                const isLight = (row + col) % 2 === 0;
                
                square.className = `square ${isLight ? 'light' : 'dark'}`;
                square.id = `sq-${displayIndex}`;
                square.dataset.index = displayIndex;
                square.onclick = () => handleSquareClick(displayIndex);
                
                board.appendChild(square);
            }
        }

        function updateBoardWithData(boardData) {
            // Piece type names mapping
            const pieceTypeNames = {
                1: 'pawn',
                2: 'knight',
                3: 'bishop',
                4: 'rook',
                5: 'queen',
                6: 'king'
            };
            
            // Only update pieces that actually changed
            boardData.forEach((piece, index) => {
                const square = document.getElementById(`sq-${index}`);
                if (square) {
                    const previousPiece = previousBoard ? previousBoard[index] : null;
                    
                    // Check if piece changed at this square
                    const pieceChanged = !previousPiece || 
                        previousPiece.piece !== piece.piece || 
                        previousPiece.color !== piece.color;
                    
                    if (pieceChanged) {
                        square.innerHTML = '';
                        
                        if (piece.piece) {
                            const pieceEl = document.createElement('div');
                            pieceEl.className = `piece ${piece.color}`;
                            pieceEl.textContent = piece.piece;
                            
                            // Add piece type as data attribute
                            if (piece.type) {
                                pieceEl.setAttribute('data-piece-type', pieceTypeNames[piece.type] || 'unknown');
                            }
                            
                            square.appendChild(pieceEl);
                        }
                    }
                }
            });
            
            // Store current board state
            previousBoard = JSON.parse(JSON.stringify(boardData));
        }

        function updateBoard(forceFullUpdate = false) {
            fetch(`/api/board/${GAME_ID}`)
                .then(r => r.json())
                .then(data => {
                    // Piece type names mapping
                    const pieceTypeNames = {
                        1: 'pawn',
                        2: 'knight',
                        3: 'bishop',
                        4: 'rook',
                        5: 'queen',
                        6: 'king'
                    };
                    
                    // Check if board should be flipped
                    const shouldFlip = PLAYER_TEAM === 'madrid';
                    
                    // Update all pieces
                    data.board.forEach((piece, index) => {
                        const previousPiece = previousBoard ? previousBoard[index] : null;
                        
                        // Update if piece changed or if forcing full update
                        if (forceFullUpdate || !previousPiece || 
                            previousPiece.piece !== piece.piece || 
                            previousPiece.color !== piece.color) {
                            
                            const square = document.getElementById(`sq-${index}`);
                            if (square) {
                                square.innerHTML = '';
                                
                                if (piece.piece) {
                                    const pieceEl = document.createElement('div');
                                    pieceEl.className = `piece ${piece.color}`;
                                    pieceEl.textContent = piece.piece;
                                    
                                    // Add piece type as data attribute
                                    if (piece.type) {
                                        pieceEl.setAttribute('data-piece-type', pieceTypeNames[piece.type] || 'unknown');
                                    }
                                    
                                    square.appendChild(pieceEl);
                                }
                            }
                        }
                    });
                    
                    // Store current board state for next comparison
                    previousBoard = JSON.parse(JSON.stringify(data.board));

                    // Update turn indicator
                    const turnText = data.side_to_move === 'white' 
                        ? 'Real Madrid (White)' 
                        : 'Barcelona (Black)';
                    document.getElementById('turn-indicator').textContent = `Turn: ${turnText}`;

                    // Update game status
                    const statusText = document.getElementById('status-text');
                    if (data.game_over) {
                        const winner = data.winner === 'madrid' ? 'Real Madrid' : 'Barcelona';
                        const winnerTeam = data.winner === 'madrid' ? 'madrid' : 'barcelona';
                        const winnerEmoji = winnerTeam === 'madrid' ? 'üëë' : 'üîµ';
                        
                        statusText.innerHTML = `<span class="winner-text">üéâ ${winner} Wins! üéâ</span>`;
                        document.getElementById('restart-btn').style.display = 'block';
                        
                        // Show winner modal
                        showWinnerModal(winner, winnerTeam, winnerEmoji);
                    } else {
                        statusText.textContent = 'Game in progress...';
                    }

                    selectedSquare = null;
                    clearHighlights();
                });
        }

        function handleSquareClick(index) {
            const square = document.getElementById(`sq-${index}`);
            const squareName = indexToSquareName(index);

            // If a square is already selected
            if (selectedSquare !== null) {
                // Check if this is a legal move destination
                if (legalMoves.includes(squareName)) {
                    makeMove(selectedSquare, squareName);
                    return;
                }
                // If clicking on a different piece, select that instead
                if (square.querySelector('.piece')) {
                    selectedSquare = squareName;
                    clearHighlights();
                    highlightSquare(index);
                    fetchLegalMoves(squareName);
                    return;
                }
                // Otherwise deselect
                selectedSquare = null;
                clearHighlights();
                return;
            }

            // If no square selected and this square has a piece, select it
            if (square.querySelector('.piece')) {
                selectedSquare = squareName;
                highlightSquare(index);
                fetchLegalMoves(squareName);
            }
        }

        function playMoveSound() {
            const moveSound = document.getElementById('move-sound');
            if (moveSound) {
                moveSound.currentTime = 0;
                moveSound.play().catch(e => console.log('Sound play failed:', e));
            }
        }
        
        function playCaptureSound() {
            const captureSound = document.getElementById('capture-sound');
            if (captureSound) {
                captureSound.currentTime = 0;
                captureSound.play().catch(e => console.log('Sound play failed:', e));
            }
        }
        
        function playPromotionSound() {
            const promotionSound = document.getElementById('promotion-sound');
            if (promotionSound) {
                promotionSound.currentTime = 0;
                promotionSound.play().catch(e => console.log('Sound play failed:', e));
            }
        }
        
        function playGameOverSound() {
            const gameoverSound = document.getElementById('gameover-sound');
            if (gameoverSound) {
                gameoverSound.currentTime = 0;
                gameoverSound.play().catch(e => console.log('Sound play failed:', e));
            }
        }

        function fetchLegalMoves(square) {
            fetch(`/api/legal_moves/${GAME_ID}/${square}`)
                .then(r => r.json())
                .then(data => {
                    legalMoves = data.legal_moves;
                    highlightLegalMoves(legalMoves);
                });
        }

        function makeMove(fromSq, toSq) {
            // Prevent rapid successive moves - wait 500ms between moves
            if (isWaitingForMove) {
                return;
            }
            
            isWaitingForMove = true;
            
            // Check if target square has a piece (capture)
            const toIndex = squareNameToIndex(toSq);
            const isCapture = previousBoard && previousBoard[toIndex] && previousBoard[toIndex].piece;
            
            // Play appropriate sound
            if (isCapture) {
                playCaptureSound();
            } else {
                playMoveSound();
            }
            
            fetch(`/api/move/${GAME_ID}`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({from: fromSq, to: toSq, promo: null})
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    lastMove = `${fromSq} ‚Üí ${toSq}`;
                    document.getElementById('last-move').textContent = lastMove;
                    
                    updateBoard();
                    
                    // If AI needs to move, show thinking indicator and wait for AI
                    if (data.ai_needs_to_move) {
                        document.getElementById('turn-indicator').textContent = `ü§î AI is thinking...`;
                        
                        // Wait 1.5 seconds to simulate thinking, then make AI move
                        setTimeout(() => {
                            fetch(`/api/ai_move/${GAME_ID}`, {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'}
                            })
                            .then(r => r.json())
                            .then(aiData => {
                                if (aiData.success) {
                                    document.getElementById('last-move').textContent = aiData.ai_move || 'AI moved';
                                    
                                    // Check if AI move was a capture
                                    const boardBeforeAI = JSON.parse(JSON.stringify(previousBoard));
                                    const piecesBeforeCount = boardBeforeAI.filter(sq => sq.piece).length;
                                    const piecesAfterCount = aiData.board.filter(sq => sq.piece).length;
                                    const wasCapture = piecesAfterCount < piecesBeforeCount;
                                    
                                    // Play AI move sound
                                    if (wasCapture) {
                                        playCaptureSound();
                                    } else {
                                        playMoveSound();
                                    }
                                    
                                    // Update board with AI's move
                                    updateBoardWithData(aiData.board);
                                    
                                    // Update turn indicator
                                    const turnText = aiData.side_to_move === 'white' 
                                        ? 'Real Madrid (White)' 
                                        : 'Barcelona (Black)';
                                    document.getElementById('turn-indicator').textContent = `Turn: ${turnText}`;
                                    
                                    // Check if game over
                                    if (aiData.game_over) {
                                        const winner = aiData.winner === 'madrid' ? 'Real Madrid' : 'Barcelona';
                                        const winnerTeam = aiData.winner;
                                        const winnerEmoji = winnerTeam === 'madrid' ? 'üëë' : 'üîµ';
                                        showWinnerModal(winner, winnerTeam, winnerEmoji);
                                    }
                                }
                                
                                // Allow next move after AI move
                                setTimeout(() => {
                                    isWaitingForMove = false;
                                }, 500);
                            });
                        }, 1500);
                    } else {
                        // Update turn indicator for non-AI moves
                        const turnText = data.side_to_move === 'white' 
                            ? 'Real Madrid (White)' 
                            : 'Barcelona (Black)';
                        document.getElementById('turn-indicator').textContent = `Turn: ${turnText}`;
                        
                        // Check if game over
                        if (data.game_over) {
                            const winner = data.winner === 'madrid' ? 'Real Madrid' : 'Barcelona';
                            const winnerTeam = data.winner;
                            const winnerEmoji = winnerTeam === 'madrid' ? 'üëë' : 'üîµ';
                            showWinnerModal(winner, winnerTeam, winnerEmoji);
                        }
                        
                        // Wait 500ms before allowing next move
                        setTimeout(() => {
                            isWaitingForMove = false;
                        }, 500);
                    }
                } else {
                    alert('Invalid move: ' + data.error);
                    isWaitingForMove = false;  // Reset on error
                }
            });
        }

        function undoMove() {
            fetch(`/api/undo/${GAME_ID}`, {method: 'POST'})
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        updateBoard();
                        document.getElementById('last-move').textContent = '-';
                    }
                });
        }

        function restartGame() {
            fetch(`/api/restart/${GAME_ID}`, {method: 'POST'})
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        updateBoard();
                        document.getElementById('last-move').textContent = '-';
                    }
                });
        }

        function highlightSquare(index) {
            document.getElementById(`sq-${index}`).classList.add('selected');
        }

        function highlightLegalMoves(moves) {
            moves.forEach(move => {
                const index = squareNameToIndex(move);
                document.getElementById(`sq-${index}`).classList.add('legal-move');
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(sq => {
                sq.classList.remove('selected', 'legal-move');
            });
        }

        function indexToSquareName(index) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const file = index % 8;
            const rank = Math.floor(index / 8) + 1;
            return files[file] + rank;
        }

        function squareNameToIndex(square) {
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(square[1]) - 1;
            return rank * 8 + file;
        }

        function showWinnerModal(winner, team, emoji) {
            const modal = document.getElementById('winner-modal');
            const announcement = document.getElementById('winner-announcement');
            
            // Play game over sound only if player lost
            if (team !== PLAYER_TEAM) {
                playGameOverSound();
            }
            
            // Set the team color class and content
            announcement.className = `winner-announcement ${team}-winner`;
            announcement.innerHTML = `
                <div class="winner-text-large">${emoji}</div>
                <h2 class="winner-title">${winner}</h2>
                <p class="winner-subtitle">Wins!</p>
                <div class="winner-sparkles">‚ú® üéâ ‚ú®</div>
            `;
            
            // Remove hidden class to show modal
            modal.classList.remove('hidden');
        }
    </script>
</body>
</html>
